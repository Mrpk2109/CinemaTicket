// https://wiki.openstreetmap.org/wiki/Overpass_API
const main = "https://overpass-api.de/api/interpreter";
const main1 = "https://lz4.overpass-api.de/api/interpreter";
const main2 = "https://z.overpass-api.de/api/interpreter";
const kumi = "https://overpass.kumi.systems/api/interpreter";
const kumi1 = "https://bib.kumi.systems/api/interpreter";
const kumi2 = "https://willard.kumi.systems/api/interpreter";
const kumi3 = "https://dodonna.kumi.systems/api/interpreter";
const france = "https://overpass.openstreetmap.fr/api/interpreter";
const switzerland = "https://overpass.osm.ch/api/interpreter";
const russia = "https://overpass.openstreetmap.ru/api/interpreter";
const usmil = "https://osm-overpass.gs.mil/overpass/interpreter";

var endpoints = /*#__PURE__*/Object.freeze({
    __proto__: null,
    main: main,
    main1: main1,
    main2: main2,
    kumi: kumi,
    kumi1: kumi1,
    kumi2: kumi2,
    kumi3: kumi3,
    france: france,
    switzerland: switzerland,
    russia: russia,
    usmil: usmil
});

const humanReadableBytes = (bytes) => {
    return bytes > 1024 * 1024
        ? `${Math.round((bytes / (1024 * 1024)) * 100) / 100}MiB`
        : `${Math.round((bytes / 1024) * 100) / 100}KiB`;
};
const matchAll = (regex, string) => {
    let match, matches = [];
    while ((match = regex.exec(string)))
        matches.push(match[1]);
    return matches;
};
const sleep = (ms) => {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
};
const consoleMsg = (msg) => {
    console.log(`${new Date(Date.now()).toISOString()} Overpass: ${msg}`);
};
// export const oneLessRetry = (opts: OverpassOptions) =>
//   Object.assign({}, opts, {
//     numRetries: opts.numRetries - 1,
//   });
class OverpassError extends Error {
    constructor(message) {
        super(`Overpass Error: ${message}`);
    }
}
const buildQueryObject = (query, overwriteObj = {}) => {
    let queryObj;
    // build query object if we just get query string
    if (typeof query === "string")
        queryObj = {
            query: query,
        };
    else if (!("query" in query))
        throw new Error("Query Object must have {query}");
    else
        queryObj = query;
    // overwrite options
    queryObj = Object.assign({}, { name: null, output: "raw", options: {} }, queryObj, overwriteObj);
    return queryObj;
};

var realFetch = require('node-fetch');
module.exports = function(url, options) {
	if (/^\/\//.test(url)) {
		url = 'https:' + url;
	}
	return realFetch.call(this, url, options);
};

if (!global.fetch) {
	global.fetch = module.exports;
	global.Response = realFetch.Response;
	global.Headers = realFetch.Headers;
	global.Request = realFetch.Request;
}

const defaultOverpassOptions = {
    endpoint: main,
    verbose: false,
    userAgent: "overpass-ts",
};
const overpass = (query, overpassOpts = {}) => {
    const opts = Object.assign({}, defaultOverpassOptions, overpassOpts);
    if (opts.verbose) {
        consoleMsg(`endpoint ${opts.endpoint}`);
        consoleMsg(`query ${query}`);
    }
    const fetchOpts = {
        body: `data=${encodeURIComponent(query)}`,
        method: "POST",
        mode: "cors",
        redirect: "follow",
        headers: {
            Accept: "*",
            "Cache-control": "no-cache",
            "Pragma": "no-cache",
            "User-Agent": opts.userAgent,
        },
    };
    return fetch(opts.endpoint, fetchOpts).then(async (resp) => {
        // throw error on non-200
        if (!resp.ok) {
            switch (resp.status) {
                case 400:
                    // 400 bad request
                    // if bad request, error details sent along as html
                    // load the html and parse it for detailed error
                    const errors = matchAll(/<\/strong>: ([^<]+) <\/p>/g, await resp.text()).map((error) => error.replace(/&quot;/g, '"'));
                    throw new OverpassBadRequestError(query, errors);
                case 429:
                    throw new OverpassRateLimitError();
                case 504:
                    throw new OverpassGatewayTimeoutError();
                default:
                    throw new OverpassError(`${resp.status} ${resp.statusText}`);
            }
        }
        // print out response size if verbose
        if (opts.verbose && resp.headers.has("content-length"))
            consoleMsg(`response payload ${humanReadableBytes(parseInt(resp.headers.get("content-length")))}`);
        return resp;
    });
};
const overpassJson = (query, opts = {}) => {
    return overpass(query, opts)
        .then((resp) => resp.json())
        .then((json) => {
        // https://github.com/drolbr/Overpass-API/issues/94
        // a "remark" in the output means an error occurred after
        // the HTTP status code has already been sent
        if (json.remark)
            throw new OverpassRuntimeError([json.remark]);
        else
            return json;
    });
};
const overpassXml = (query, opts = {}) => {
    return overpass(query, opts)
        .then((resp) => resp.text())
        .then((text) => {
        // https://github.com/drolbr/Overpass-API/issues/94
        // a "remark" in the output means an error occurred after
        // the HTTP status code has already been sent
        // </remark> will always be at end of output, at same position
        if (text.slice(-18, -9) === "</remark>") {
            const textLines = text.split("\n");
            const errors = [];
            // loop backwards thru text lines skipping first 4 lines
            // collect each remark (there can be multiple)
            // break once remark is not matched
            for (let i = textLines.length - 4; i > 0; i--) {
                const remark = textLines[i].match(/<remark>\s*(.+)\s*<\/remark>/);
                if (remark)
                    errors.push(remark[1]);
                else
                    break;
            }
            throw new OverpassRuntimeError(errors);
        }
        else
            return text;
    });
};
const overpassCsv = (query, opts = {}) => {
    return overpass(query, opts).then((resp) => resp.text());
};
const overpassStream = (query, opts = {}) => {
    return overpass(query, opts).then((resp) => resp.body);
};
class OverpassRateLimitError extends OverpassError {
    apiStatus;
    constructor(apiStatus = null) {
        super("429 Rate Limit Exceeded");
        this.apiStatus = apiStatus;
    }
}
class OverpassBadRequestError extends OverpassError {
    errors;
    query;
    constructor(query, errors) {
        super([
            "400 Bad Request\n",
            "Errors:\n  ",
            errors.join("\n  "),
            "\n",
            "Query:\n  ",
            query.replace(/\n/g, "\n  "),
        ].join(""));
        this.errors = errors;
        this.query = query;
    }
}
class OverpassRuntimeError extends OverpassError {
    errors;
    constructor(errors) {
        super(errors.join("\n  "));
        this.errors = errors;
    }
}
class OverpassGatewayTimeoutError extends OverpassError {
    constructor() {
        super("504 Gateway Timeout");
    }
}

const defaultApiStatusOptions = {
    verbose: false,
};
const apiStatus = (endpoint, apiStatusOpt = {}) => {
    const opts = Object.assign({}, defaultApiStatusOptions, apiStatusOpt);
    const endpointURL = typeof endpoint === "string" ? new URL(endpoint) : endpoint;
    return fetch(endpointURL.href.replace("/interpreter", "/status"))
        .then((resp) => {
        const responseType = resp.headers.get("content-type");
        if (!responseType || responseType.split(";")[0] !== "text/plain")
            throw new OverpassApiStatusError(`Response type incorrect (${responseType})`);
        return resp.text();
    })
        .then((statusHtml) => {
        const apiStatus = parseApiStatus(statusHtml);
        if (!("clientId" in apiStatus))
            throw new OverpassApiStatusError(`Unable to parse API Status`);
        if (opts.verbose)
            consoleMsg([
                endpointURL.host,
                "status",
                [
                    `(rl ${apiStatus.rateLimit}`,
                    `sl ${apiStatus.slotsLimited.length}`,
                    `sr ${apiStatus.slotsRunning.length})`,
                ].join(" "),
            ].join(" "));
        return apiStatus;
    });
};
const parseApiStatus = (statusHtml) => {
    const status = {
        slotsRunning: [],
        slotsLimited: [],
    };
    statusHtml.split("\n").forEach((statusLine) => {
        const lineFirstWord = statusLine.split(" ")[0];
        if (lineFirstWord == "Connected")
            status["clientId"] = statusLine.slice(14);
        else if (lineFirstWord == "Current")
            status["currentTime"] = statusLine.slice(14);
        else if (lineFirstWord == "Rate")
            status["rateLimit"] = parseInt(statusLine.slice(12));
        else if (lineFirstWord == "Slot")
            status["slotsLimited"].push([statusLine.slice(22).split(", ")].map((splitLine) => ({
                time: splitLine[0],
                seconds: parseInt(splitLine[1].split(" ")[1]),
            }))[0]);
        // any lines not "Currently running queries" or "# slots available now"
        // or empty, count those as slots running lines
        else if (lineFirstWord != "Currently" &&
            !statusLine.includes("available") &&
            statusLine !== "")
            status["slotsRunning"].push([statusLine.split("\t")].map((splitLine) => ({
                pid: parseInt(splitLine[0]),
                spaceLimit: parseInt(splitLine[1]),
                timeLimit: parseInt(splitLine[2]),
                startTime: splitLine[3],
            }))[0]);
    });
    return status;
};
class OverpassApiStatusError extends OverpassError {
    constructor(message) {
        super(`API Status error: ${message}`);
    }
}

const defaultOverpassEndpointOptions = {
    gatewayTimeoutPause: 2000,
    rateLimitPause: 5000,
    minRequestInterval: 2000,
    verbose: false,
    maxSlots: 4,
};
class OverpassEndpoint {
    statusTimeout = null;
    status = null;
    statusAvailable = true;
    opts;
    queue = [];
    queueIndex = 0;
    queueRunning = 0;
    uri;
    constructor(uri, opts = {}) {
        this.opts = Object.assign({}, defaultOverpassEndpointOptions, opts);
        this.uri = new URL(uri);
    }
    updateStatus() {
        // clear status timeout it already exists
        if (this.statusTimeout) {
            clearTimeout(this.statusTimeout);
            this.statusTimeout = null;
        }
        return apiStatus(this.uri.href, { verbose: this.opts.verbose })
            .then((apiStatus) => {
            this.status = apiStatus;
            // if there's any rate limited slots and something in the queue
            // set timeout to update status once the rate limit is over
            if (this.status.slotsLimited.length == this.getRateLimit() //&&
            // (this.queueIndex < this.queue.length || this.queue.length == 0)
            ) {
                const lowestRateLimitSeconds = Math.min(...this.status.slotsLimited.map((slot) => slot.seconds)) +
                    0.1;
                if (this.opts.verbose &&
                    this.status.slotsLimited.length == this.getRateLimit())
                    consoleMsg(`${this.uri.host} rate limited; waiting ${lowestRateLimitSeconds}s`);
                this.statusTimeout = setTimeout(async () => {
                    await this.updateStatus();
                }, lowestRateLimitSeconds * 1000);
            }
        })
            .catch((error) => {
            // silently error apiStatus (some endpoints don't support /api/status)
            if (this.opts.verbose)
                consoleMsg(`${this.uri.host} ERROR getting api status (${error.message})`);
            // set status to false if status endpoint broken
            // make sure we don't ask again
            this.statusAvailable = false;
        });
    }
    async _query(queryObj) {
        // add query to queue
        const queryIdx = this.queue.push(queryObj);
        // if no name specified in query, use the queue index as name
        if (!queryObj.name) {
            queryObj.name = (queryIdx - 1).toString();
        }
        if (this.opts.verbose)
            consoleMsg(`${this.uri.host} query ${queryObj.name} queued`);
        // initialize endpoint status if endpoint is idle (no queries in queue)
        if (!this.status &&
            this.statusAvailable &&
            this.queue.length - 1 == this.queueIndex)
            await this.updateStatus();
        // poll queue until a slot is open and then execute query
        return new Promise((res) => {
            const waitForQueue = () => {
                const slotsAvailable = this.getSlotsAvailable();
                if (queryIdx <= this.queueIndex + slotsAvailable) {
                    this.queueIndex++;
                    this.queueRunning++;
                    setTimeout(() => {
                        res(this._sendQuery(queryObj));
                    }, (this.queueIndex + slotsAvailable - queryIdx - 1) * this.opts.minRequestInterval);
                }
                else
                    setTimeout(waitForQueue, 100);
            };
            waitForQueue();
        });
    }
    query(query) {
        return this._query(buildQueryObject(query, {
            output: "raw",
        }));
    }
    queryJson(query) {
        return this._query(buildQueryObject(query, { output: "json" }));
    }
    queryXml(query) {
        return this._query(buildQueryObject(query, { output: "xml" }));
    }
    queryCsv(query) {
        return this._query(buildQueryObject(query, { output: "csv" }));
    }
    queryStream(query) {
        return this._query(buildQueryObject(query, { output: "stream" }));
    }
    _sendQuery(query) {
        if (this.opts.verbose)
            consoleMsg(`${this.uri.host} query ${query.name} sending`);
        // choose overpass function to use based upon desired output
        // allows for checking of runtime errors early in promise chain
        let overpassFn;
        if (query.output == "json")
            overpassFn = overpassJson;
        else if (query.output == "xml")
            overpassFn = overpassXml;
        else if (query.output == "csv")
            overpassFn = overpassCsv;
        else if (query.output == "stream")
            overpassFn = overpassStream;
        else
            overpassFn = overpass;
        return overpassFn(query.query, {
            ...query.options,
            endpoint: this.uri.href,
        })
            .then(async (resp) => {
            if (this.opts.verbose)
                consoleMsg(`${this.uri.host} query ${query.name} complete`);
            this.queueRunning--;
            if (this.statusAvailable) {
                // if query isn't last one in queue, update status
                //if (this.queueIndex < this.queue.length)
                await this.updateStatus();
                // if query is last, set status = null
                // so a fresh status will be requested if new queries performed
                //else this.status = null;
            }
            return resp;
        })
            .catch(async (error) => {
            if (error instanceof OverpassRateLimitError) {
                // if query is rate limited, poll until we get slot available
                if (this.opts.verbose)
                    consoleMsg(`${this.uri.host} query ${query.name} rate limited`);
                return new Promise(async (res) => {
                    const waitForRateLimit = () => {
                        // +1 to account for slotsAvailable not accounting for this
                        // particular rate limited request
                        if (this.getSlotsAvailable() + 1 > 0)
                            res(this._sendQuery(query));
                        else
                            setTimeout(waitForRateLimit, 100);
                    };
                    if (this.statusAvailable) {
                        await this.updateStatus();
                    }
                    else
                        await sleep(this.opts.rateLimitPause);
                    waitForRateLimit();
                });
            }
            else if (error instanceof OverpassGatewayTimeoutError) {
                // if query is gateway timeout, pause some ms and send again
                if (this.opts.verbose)
                    consoleMsg(`${this.uri.host} query ${query.name} gateway timeout`);
                return sleep(this.opts.gatewayTimeoutPause).then(() => this._sendQuery(query));
            }
            else {
                // if is other error throw it to be handled downstream
                if (this.opts.verbose)
                    consoleMsg(`${this.uri.host} query ${query.name} uncaught error (${error.message})`);
                this.queueRunning--;
                if (!this.statusTimeout && this.statusAvailable)
                    await this.updateStatus();
                throw error;
            }
        });
    }
    getRateLimit() {
        if (this.status) {
            // if status is loaded and has limited rate limit return that
            if (this.status.rateLimit > 0)
                return this.status.rateLimit;
            // if unlimited rate limit, return default maxSlots
            else
                return this.opts.maxSlots;
        }
        else {
            // if status is unavailable return default maxSlots
            if (!this.statusAvailable)
                return this.opts.maxSlots;
            // if status isn't loaded but still available (initial load) return 0
            else
                return 0;
        }
    }
    getSlotsAvailable() {
        const rateLimit = this.getRateLimit();
        if (this.status) {
            // include slotsLimited in available calculation if there's nothing
            // running in the queue (happens on startup)
            return rateLimit - this.queueRunning - this.status.slotsLimited.length;
        }
        else {
            // if status isn't loaded but still available (initial load) return 0
            if (this.statusAvailable)
                return 0;
            // if endpoint has broken /api/status just don't include limited slots
            else
                return rateLimit - this.queueRunning;
        }
    }
}

const defaultOverpassManagerOptions = {
    endpoints: main,
    maxSlots: 4,
    numRetries: 1,
    retryPause: 2000,
    verbose: false,
};
class OverpassManager {
    opts = defaultOverpassManagerOptions;
    endpoints = [];
    endpointsInitialized = false;
    constructor(opts = {}) {
        this.opts = Object.assign({}, defaultOverpassManagerOptions, opts);
        this.endpoints = [this.opts.endpoints]
            .flat()
            .map((endpointUri) => new OverpassEndpoint(endpointUri, { verbose: this.opts.verbose }));
    }
    async _query(query) {
        if (!this.endpointsInitialized) {
            this.endpointsInitialized = true;
            await Promise.all(this.endpoints.map((endpoint) => endpoint.updateStatus()));
        }
        return new Promise((res) => {
            const waitForAvailableEndpoint = () => {
                const endpoint = this._getAvailableEndpoint();
                if (endpoint)
                    res(endpoint._query(query));
                else
                    setTimeout(waitForAvailableEndpoint, 100);
            };
            waitForAvailableEndpoint();
        });
    }
    query(query) {
        return this._query(buildQueryObject(query, {
            output: "raw",
        }));
    }
    queryJson(query) {
        return this._query(buildQueryObject(query, { output: "json" }));
    }
    queryXml(query) {
        return this._query(buildQueryObject(query, { output: "xml" }));
    }
    queryCsv(query) {
        return this._query(buildQueryObject(query, { output: "csv" }));
    }
    queryStream(query) {
        return this._query(buildQueryObject(query, { output: "stream" }));
    }
    _getAvailableEndpoint() {
        for (let endpoint of this.endpoints) {
            if (endpoint.getSlotsAvailable() > 0)
                return endpoint;
        }
        return null;
    }
}

export { OverpassApiStatusError, OverpassBadRequestError, OverpassEndpoint, OverpassGatewayTimeoutError, OverpassManager, OverpassRateLimitError, OverpassRuntimeError, apiStatus, defaultApiStatusOptions, defaultOverpassOptions, endpoints, overpass, overpassCsv, overpassJson, overpassStream, overpassXml, parseApiStatus };
